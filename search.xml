<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>怎么理解回流跟重绘？什么场景下会触发？</title>
      <link href="/2023/03/28/qian-duan-zhi-shi-dian/li-jie-ye-mian-hui-liu-he-chong-hui/"/>
      <url>/2023/03/28/qian-duan-zhi-shi-dian/li-jie-ye-mian-hui-liu-he-chong-hui/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h1><p>我们在写html页面的时候，可以把每个标签都理解成一个盒子，在通过浏览器打开的时候，页面呈现出你想要的样子，浏览器在解析的过程中就会涉及到回流和重绘。</p><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><blockquote><p>当元素的尺寸、结构等属性改变时，浏览器重新渲染部分或者全部文档的过程称为回流，一下几点会引起回流。</p></blockquote><ul><li>首次加载页面（这避免不了）</li><li>浏览器窗口大小改变（因为回流是根据视口的大小来计算元素的位置和大小的）</li><li>元素尺寸或者位置改变（包括外边距、内边框、边框大小、高度和宽度等）</li><li>元素内容改变（比如文本变化或图片被另一个不同尺寸的图片所替代）</li><li>字体大小改变</li><li>添加或者删除dom元素</li><li>伪类触发:hover<br>容易被忽略的属性：<pre><code>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</code></pre>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流，除此还包括getComputedStyle 方法，原理是一样的</li></ul><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><blockquote><p>当页面中元素的样式改变并不影响它在文档中的位置，浏览器会将新样式赋予元素并重新绘制他，这个叫重绘。</p></blockquote><ul><li>color</li><li>bachground-color</li><li>visibility</li><li>…  </li></ul><p>具体的浏览器解析渲染机制如下所示：<br><img src="/2023/03/28/qian-duan-zhi-shi-dian/li-jie-ye-mian-hui-liu-he-chong-hui/1.png" alt><br>1、解析HTML，生成DOM树，解析CSS，生成CSSOM树<br>2、将DOM树和CSSOM树结合，生成渲染树(Render Tree)<br>3、Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）<br>4、Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素<br>5、Display:将像素发送给GPU，展示在页面上</p><h1 id="回流和重绘的区别"><a href="#回流和重绘的区别" class="headerlink" title="回流和重绘的区别"></a>回流和重绘的区别</h1><ul><li>回流必将引起重绘，而重绘不一定会引起回流（只有颜色改变的时候就只会发生重绘而不会引起回流）。</li><li>当页面布局和几何属性改变时就需要回流（添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变）。</li></ul><h1 id="如何去减少"><a href="#如何去减少" class="headerlink" title="如何去减少"></a>如何去减少</h1><p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的一些常用建议：</p><ul><li>如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)</li><li>避免设置多项内联样式</li><li>应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)</li><li>避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算</li><li>对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li><li>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</li><li>避免使用 CSS 的 JavaScript 表达式</li><li>在使用 JavaScript 动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能</li></ul><p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p><h2 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h2><p>避免一条一条的去添加样式</p><pre><code>&lt;div id="box"&gt;&lt;/div&gt;&lt;script&gt;var oBox = document.getElementById('#box')box.style.width = 300 + 'px'box.style.height = 300 + 'px'box.style.fontSize = 28 + 'px'&lt;/script&gt;  </code></pre><p>可以把样式通过一个calss名，做一次的插入</p><pre><code>&lt;div id="box" class="box-sytle"&gt;&lt;/div&gt;&lt;style&gt;.box{    width: 300px;    hgeight: 300px;    font-size: 28px;}&lt;/style&gt;&lt;script&gt;var oBox = document.getElementById('#box')box.classList.add('box-sytle')&lt;/script&gt;</code></pre><p>在js做循环dom插入的时候，可以先让入documentFragment,然后一次性的插入</p><pre><code>&lt;script&gt; var oFramenet = document.createDocumentFragment(); //创建碎片 var oUl = document.createElement('ul') for(var i=0; i&lt;5; i++){     oLi = '&lt;li&gt;' + i + '&lt;/li&gt;'          oFramenet.appendChild(oLi) } oUl.appendChild(oFramenet) document.body.appendChild(oUl)&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题锦集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>typescript中的函数</title>
      <link href="/2022/12/28/javascript/typescript/typescript-zhong-de-han-shu/"/>
      <url>/2022/12/28/javascript/typescript/typescript-zhong-de-han-shu/</url>
      
        <content type="html"><![CDATA[<p>ES5中我们通常定义函数的方法</p><pre><code>//函数声明function run(){    return '函数声明'}//匿名函数var test1 = function(){    return '匿名函数'} </code></pre><p>TS中我们定义函数</p><pre><code>//1、函数声明式定义function test():string{    return '123'}function test():number{    return '123'  //× 返回值类型与定义的返回值类型不一致}//2、匿名函数定义var test1 = function():void{    console.log('123')}//3、定义方法参数function test1(name:string, age:number):string{    return `我的名字叫${name},我今年${age}`;}test1('zhangsan', 20) //√test1('zhangsan', '20') //×//4、配置可选参数function test1(name:string, age?:number):string{    if(age){        return `我的名字叫${name},我今年${age}`;    }else{        return `我的名字叫${name}`;    }}test1('zhangsan', 30) // √test1('zhangsan') // √</code></pre><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><pre><code>//剩余参数(放在所有参数最后)function sum(f:number, ...args:number[]):number{    console.log(f);        var total:number = 0;    for(var i=0; i&lt;args.length; i++){        total+= args[i]    }    return total;}console.log(sum(1,2,3,4,5));</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> script </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>typescript中的数据类型</title>
      <link href="/2022/12/22/javascript/typescript/typescript-zhong-de-shu-ju-lei-xing/"/>
      <url>/2022/12/22/javascript/typescript/typescript-zhong-de-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<ul><li>字符串类型<pre><code>let str:string = 'zhangsan'str = 50  //重新复制数值类型报错</code></pre></li><li>数字类型<pre><code>let num:number = 30num = 'wangwu' //重新复制数值类型报错</code></pre></li><li>布尔类型<pre><code>let tf:boolean = truetf = 'wangwu' //重新复制数值类型报错</code></pre></li><li>数组类型<pre><code>let arr1:Array&lt;number&gt; = [15,10,13] //√arr1:Array&lt;number&gt; = [15,'10',13] //×，含有字符串报错</code></pre></li></ul><hr><p>let arr1:any = [15,’10’,13]<br>console.log(arr1) //√不会报错，属于any类型</p><pre><code>- 元祖类型（tulp属于数组的一种）  类似于es5中不规定类型一样</code></pre><p>let oBox:any = document.getElementById(‘box’)<br>oBox.style.color = ‘red’ //报错oBox没有Object类型，这个是否定义any比较合适  </p><pre><code>- 枚举类型（enum）</code></pre><p>enum message {<br>    success = 200,<br>    error = 400,<br>    wait<br>}<br>console.log(message.success) //√,200<br>console.log(message.wait) //√,401以上一个元素如果是数值会接着上一个数值开始</p><pre><code>- 其他类型null、undefined</code></pre><p>let num:number<br>console.log(num) //报错,输出undefined</p><hr><p>let num:undefined<br>console.log(num) //√,输出undefined</p><hr><p>let num:number|undefined;<br>//num = 123<br>//console.log(num) //√,输出123<br>//如果不定义<br>console.log(num) //√,输出undefined也是正确的</p><pre><code>- void类型一个方法没有任何返回值的时候给定的类型</code></pre><p>//这个方法没有任何返回值<br>function test():void{<br>    console.log(‘void这个方法没有任何的返回值!’)<br>}</p><p>//这个方法返回字符串类型，其他一次类推<br>function test():string{<br>    return ‘我返回字符串类型的值’<br>}</p><pre><code>- never类型是其他类型包括（null, undefined）类型的子类型，声明never类型的变量只能never类型赋值</code></pre><p>let num:undefined<br>num = 123 //×<br>num = undefined //√<br>```</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> script </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>promise的个人理解</title>
      <link href="/2022/11/22/javascript/promise/promise-de-li-jie/"/>
      <url>/2022/11/22/javascript/promise/promise-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>简单从语法上讲promise是一个对象，可以获异步的一个操作结果，从语义上讲，它代表的意思是一个承诺，承诺一段时间内会给出一个结果。每个promise都有三种状态：pending(进行中)、fulilled(完成)、rejected(失败)，状态一旦改变，就不会在随着后续操作再次改变。通过new一个promise实例后，它会立即执行</p><pre><code>let promise = new Promise(function(resolve, reject) {  console.log('Promise');  resolve();});promise.then(function() {  console.log('resolved.');});console.log('Hi!');  </code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。  </p><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>在异步操作中，往往通过回调函数来获得操作结果，如果出现多层相互嵌套就会形成回调地狱，并且代码可读性非常差。通过promise我们可以像通过操作同步代码一样去操作异步代码</p><h3 id="它有什么缺点"><a href="#它有什么缺点" class="headerlink" title="它有什么缺点"></a>它有什么缺点</h3><p>1、一旦创建立即执行，无法在中途进行取消；<br>2、操作结果一旦确定就会定型后续操作无法改变状态;<br>3、无法确定pending状态发展到那个阶段；</p><h3 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h3><p>可以通过new一个Promise的构造函数,生成一个promise的实例对象</p><pre><code>new Promise((resolve, reject)=&gt;{    if(/*异步操作成功*/){        resolve('success')    }else{        reject('err')    }})</code></pre><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数：</p><pre><code>promise.then(function(value){    //接受resolve(value)状态为resolved时候调用}, function(err){    // 接受reject('err')状态为rejected时候调用})</code></pre><p>一个简单的例子：</p><pre><code>function tme(ms){    return new Promise(function(resolve, reject){        setTimeout(resolve, ms, 'success')    })}tme(2000).then(function(value) =&gt; {    console.log(res)})</code></pre><p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞明白Object.defineProperty()的使用</title>
      <link href="/2022/07/23/javascript/ri-chang-zong-jie/defineproperty/"/>
      <url>/2022/07/23/javascript/ri-chang-zong-jie/defineproperty/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p><blockquote><p>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。  </p></blockquote><p>api的使用</p><pre><code>Object.defineProperty(obj, prop, descriptor)//实例var person = {}Object.defineProperty(person,'a',{    configurable:true,//表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改    enumerable:true,//可以被枚举    writable:true,//可以修改这个属性的值    value:1//定义一个初始的值为1})console.log(person)//Object {a: 1}person.a=2console.log(person)//Object {a: 2}for(var k in person){    console.log(k)//a,可以被枚举}</code></pre><p>1、configurable</p><blockquote><p>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符（descriptor）才能够被改变，同时该属性也能从对应的对象上被删除,默认为 false。</p></blockquote><ul><li>这个属性起到两个作用：<br>  +目标属性是否可以使用delete删除<br>  +目标属性是否可以再次设置特性（descriptor）<pre><code>//**********************测试目标属性是否能被删除**********************-------var obj = {}//第一种情况：configurable设置为false，不能被删除。Object.defineProperty(obj,"a",{  value:"1",  writable:false,  enumerable:false,  configurable:false});//删除属性delete obj.a;console.log( obj.a ); //依然是1，因为configurable:false</code></pre></li></ul><p>//第二种情况：configurable设置为true，可以被删除。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false,<br>    enumerable:false,<br>    configurable:true<br>});<br>//删除属性<br>delete obj.a;<br>console.log( obj.a ); //返回undefined说明删除成功,因为configurable:true</p><p>//<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>测试是否可以再次修改特性<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>——-<br>var obj = {}<br>//第一种情况：configurable设置为false，不能再次修改特性（descriptor）。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false,<br>    enumerable:false,<br>    configurable:false<br>});</p><p>//重新修改特性<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:true, //修改后<br>    enumerable:true, //修改后<br>    configurable:true<br>});<br>console.log( obj.a ); //报错：Uncaught TypeError: Cannot redefine property: a</p><p>//第二种情况：configurable设置为true，可以再次修改特性。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false,<br>    enumerable:false,<br>    configurable:true<br>});</p><p>//重新修改特性<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:true,<br>    enumerable:true,<br>    configurable:true<br>});<br>console.log( obj.a ); //1</p><pre><code>2、enumerable&gt;当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中,默认为 false ;</code></pre><p>var obj = {}<br>//第一种情况：enumerable设置为false，不能被枚举。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false,<br>    enumerable:false<br>});</p><p>//枚举对象的属性<br>for( var attr in obj ){<br>    console.log( attr );<br>}<br>//第二种情况：enumerable设置为true，可以被枚举。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false,<br>    enumerable:true<br>});</p><p>//枚举对象的属性<br>for( var attr in obj ){<br>    console.log( attr );  //a<br>}</p><pre><code>3、writable&gt;当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变默认为false;</code></pre><p>//属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。</p><p>var obj = {}<br>//第一种情况：writable设置为false，不能重写。<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:false<br>});<br>//更改a的值<br>obj.a = “change value”;<br>console.log( obj.a );  //1</p><p>//第二种情况：writable设置为true，可以重写<br>Object.defineProperty(obj,”a”,{<br>    value:”1”,<br>    writable:true<br>});<br>//更改a的值<br>obj.a = “change value”;</p><pre><code>4、我们看看访问器属性&gt; 当使用存取器描述属性的特性的时候，允许设置以下特性属性,注意：当使用了getter或setter方法，不允许使用writable和value这两个属性</code></pre><p>var obj = {};<br>Object.defineProperty(obj,”a”,{<br>    configurable: true | false,<br>    enumerable: true | false,<br>    get:function (){} | undefined,<br>    set:function (value){} | undefined<br>});</p><pre><code>看一个示例</code></pre><p> var person = {<br>    a:1<br>  }<br>  Object.defineProperty(person,’a’,{<br>    get(){<br>        return 3 //当访问这个属性的时候返回3<br>    },<br>    set(val){<br>        console.log(val)//当设置这个属性的时候执行,val是设置的值<br>    }<br>})</p><p>person.a// 3,我们明明写的是a:1,怎么返回的3呢?这就是get()的威力了<br>person.a = 5// 5,相应的设置的时候执行了set()函数</p><pre><code>在来模拟一个访问和设置的默认行为</code></pre><p>var person = {<br>    a:1<br>}</p><h1 id="注-里面的this指向ogj-person"><a href="#注-里面的this指向ogj-person" class="headerlink" title="注:里面的this指向ogj(person)"></a>注:里面的this指向ogj(person)</h1><p>Object.defineProperty(person,’a’,{<br>    get(){<br>        return this.a<br>    },<br>    set(val){<br>        this.a = val<br>    }<br>})<br>//我们想当然的这么写.<br>//person.a//Uncaught RangeError: Maximum call stack size exceeded<br>//什么,溢出了?这是为什么?<br>//哦~原来是这么写的话会造成循环引用,狂call不止<br>//我们看下流程:<br>//person.a → get.call(person) → this.a → person.a  → get.call(person) → this.a……</p><pre><code>需要修改如下：</code></pre><p>var person = {<br>    a:1<br>}<br>Object.defineProperty(person,’a’,{<br>    get(){<br>        return this._a || 1 //定义一个新的属性和一个默认值<br>    },<br>    set(val){<br>        this._a = val<br>    }<br>})<br>person.a// 1<br>person.a=2// 2<br>person.a// 2<br>```</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>升级hexo和nodejs导致hexo命名报错问题</title>
      <link href="/2022/07/23/hexo/hexo-zhong-node-ban-ben-wen-ti/"/>
      <url>/2022/07/23/hexo/hexo-zhong-node-ban-ben-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="迁移Hexo到Node-js-14-解决部署时报错"><a href="#迁移Hexo到Node-js-14-解决部署时报错" class="headerlink" title="迁移Hexo到Node.js 14 解决部署时报错"></a>迁移Hexo到Node.js 14 解决部署时报错</h3><ul><li><p>概述</p><blockquote><p>升级nodejs之后执行原来的hexo d发布到git上结构报错</p></blockquote></li><li><p>环境</p><blockquote><p>Node.js 14.17.4, Hexo-cli 4.3.0, Hexo 5.4.0</p></blockquote></li><li><p>报错内容</p><pre><code>The "mode" argument must be integer. Received an instance of Object</code></pre></li></ul><pre><code>WARN  Deprecated config detected: "external_link" with a Boolean value is deprecated. See https://hexo.io/docs/configuration for more details.</code></pre><ul><li><p>解决</p><blockquote><p>降低node版本到12.17.0（缺点不够优雅，有的项目需要另外的版本）<br>使用nvm管理node不同版本</p></blockquote></li><li><p>hexo最佳版本匹配</p><pre><code>node：12.18.3  cnpm: 7.1.0</code></pre><blockquote><p>如果使用nvm管理node的时候  需要切换到对应的node版本之后  在装对应的cnpm版本</p></blockquote></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决GitHub报错You‘re using an RSA key with SHA-1, which is no longer allowed.Please use a newer client</title>
      <link href="/2022/07/23/git/chang-jian-wen-ti/pei-zhi-xiang-guan/sshkey/"/>
      <url>/2022/07/23/git/chang-jian-wen-ti/pei-zhi-xiang-guan/sshkey/</url>
      
        <content type="html"><![CDATA[<p>解决GitHub报错You‘re using an RSA key with SHA-1, which is no longer allowed. Please use a newer client  </p><p>在使用git pull的时候出现下面的错误提示<br>You’re using an RSA key with SHA-1, which is no longer allowed. Please use a newer client</p><p>原因：GitHub 在 2022 年 3 月 15 日之后将不再支持 RSA 算法生成的密钥，原因是 RSA 不够安全，而笔者之前一直是使用如下命令生成密钥对的所以提示使用sha</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>生成新的Ed25519密钥对：</p><pre><code>ssh-keygen -t ed25519 -C "your-email"</code></pre><p>命令会生成两个新的密钥对:</p><pre><code>id_ed25519id_ed25519.pub</code></pre><p>然后去github =&gt; setting =&gt; SSH and GPG keys里面，将原来的不支持的对应机器的key删除掉，然后添加新生成的key（id_ed25519.pub）就行了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh_key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eventloop个人理解</title>
      <link href="/2022/03/24/javascript/eventloop/eventloop/"/>
      <url>/2022/03/24/javascript/eventloop/eventloop/</url>
      
        <content type="html"><![CDATA[<h2 id="js事件循环机制在浏览器端（Event-Loop）以及async-await的理解"><a href="#js事件循环机制在浏览器端（Event-Loop）以及async-await的理解" class="headerlink" title="js事件循环机制在浏览器端（Event Loop）以及async/await的理解"></a>js事件循环机制在浏览器端（Event Loop）以及async/await的理解</h2><p>先看如下的一段代码</p><pre><code>console.log(1)async fun1(){    console.log(2)    await fun2()    console.log(3)  // 遇到await的时候会去执行外面的同步代码，当同步代码执行完毕在继续执行await后面的代码然后在执行本次循环的微任务代码}setTimeout(function(){    console.log(5)},0)fun2(){    console.log(4)}fun1()new Promise((resolve)=&gt;{    console.log(6)    resolve()}).then((res)=&gt;{    console.log(7)})console.log(8)// 1  2  4  3  8  6  7  5</code></pre><p>我们可以将js的任务分为同步任务和异步任务, 按照这种分类js的执行机制如下：</p><ul><li>任务执行队列分为同步任务队列和异步任务队列</li><li>代码执行时，遇到同步代码，会被直接推入同步任务队列并依次执行</li><li>遇到异步代码(如setTimeout、setInterval), 会被直接推入异步任务队列</li><li>当同步任务队列执行完毕，这个时候异步任务队列的任务会被依次推入同步任务队列并依次执行  </li></ul><blockquote><p>所以上面的代码执行的时候, setTimeout()不会被立即执行，会被推到异步任务队列里面, 之后再执行console.log(2), 同步任务队列任务执行完毕之后，会去异步任务队列的任务会被依次推到 同步任务队列并执行</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vuex浅析</title>
      <link href="/2022/01/21/vue/vuex/vuex-qian-xi/"/>
      <url>/2022/01/21/vue/vuex/vuex-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote><p>定义：可以理解为它是集中式存储所有组件状态的一个小仓库,并且保持我们存储状态以一种可以预测的方式发生变化。  </p></blockquote><h4 id="一、想象一个场景"><a href="#一、想象一个场景" class="headerlink" title="一、想象一个场景"></a>一、想象一个场景</h4><h5 id="1、如果你的项目里面有很多的页面和组件，并且存在多级嵌套关系，此时这些页面需要一个共享数据，此时就会产生两个问题"><a href="#1、如果你的项目里面有很多的页面和组件，并且存在多级嵌套关系，此时这些页面需要一个共享数据，此时就会产生两个问题" class="headerlink" title="1、如果你的项目里面有很多的页面和组件，并且存在多级嵌套关系，此时这些页面需要一个共享数据，此时就会产生两个问题:"></a>1、如果你的项目里面有很多的页面和组件，并且存在多级嵌套关系，此时这些页面需要一个共享数据，此时就会产生两个问题:</h5><ul><li>多个嵌套和兄弟组件依赖同一个状态</li><li>在某个视图组件需要变更同一个状态  </li></ul><h5 id="2、如果需要解决以上问题你可能会想到一下方案："><a href="#2、如果需要解决以上问题你可能会想到一下方案：" class="headerlink" title="2、如果需要解决以上问题你可能会想到一下方案："></a>2、如果需要解决以上问题你可能会想到一下方案：</h5><ul><li>对于第一个问题，多组件嵌套，我们可以通过父子组件一层一层传递参数解决，虽然有些麻烦，但是能够解决问题，但是对于兄弟组件或者更负责的组件之间就很难办了，虽然可以通过各种办法去解决，或多或少会存在一定的问题，要么代码变得臃肿要么逻辑变的难以理解。</li><li>对于兄弟或者更负责的，可以通过父子组件直接引用，或者通过事件来变更、在这同步状态的多份拷贝  </li></ul><h5 id="3、能不能把公共的抽离出来"><a href="#3、能不能把公共的抽离出来" class="headerlink" title="3、能不能把公共的抽离出来"></a>3、能不能把公共的抽离出来</h5><ul><li>针对这样的需求，可以把各个组件需要依赖的同一个状态抽离出来，在全局中使用单例模式进行管理</li><li>这种模式下，当一个组件需要更新状态的时候，任何组件都可以实时访问到这个组件的变化，也就是所有组件都能够更新最新的变化  </li></ul><h5 id="4、这时候，Vuex诞生了！"><a href="#4、这时候，Vuex诞生了！" class="headerlink" title="4、这时候，Vuex诞生了！"></a>4、这时候，Vuex诞生了！</h5><ul><li>这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux。与其他模式不同的是，Vuex 是专门为 Vue 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</li></ul><p>这是官网对vuex的一张图:<br><img src="/2022/01/21/vue/vuex/vuex-qian-xi/5.jpg" alt="">  </p><p><strong>什么时候应该用vuex呢？</strong>  </p><ul><li>这个问题因人而异，如果你不需要开发大型的单页应用，此时你完全没有必要使用vuex，比如你的页面就两三个，使用vuex后增加的文件比你现在的页面还要多，那就没这个必要了。  </li><li>假如你的项目达到了中大型应用的规模，此时您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。  </li></ul><h4 id="安装vuex"><a href="#安装vuex" class="headerlink" title="安装vuex"></a>安装vuex</h4><p>进入项目，在命令行中输入命令  </p><pre><code>cnpm i -S vuex</code></pre><p>然后配置 vuex，使其工作起来：在src路径下创建store文件夹，然后创建index.js文件，文件内容如下：  </p><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store({    state: {        name: 'zhangsan',        age: 20,        friends: [            {name:'wanger', age:18},            {name:'lisi', age:36},            {name:'mazi', age:46}        ]    },})</code></pre><p>main.js文件做如下修改:    </p><pre><code>import Vue from 'vue'import App from './App'import Router from './router'import Store from './store'Vue.config.productionTip = false;new Vue({    el: '#app',    Router,    Store,    components: {App},    template: '&lt;App /&gt;'})</code></pre><h4 id="组件中使用vuex"><a href="#组件中使用vuex" class="headerlink" title="组件中使用vuex"></a>组件中使用vuex</h4><p>1、在App.vue中加入：   </p><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;div&gt;{{$store.state.name}}&lt;/div&gt; // ---&gt;  zhangsan        &lt;div&gt;{{getName()}}&lt;/div&gt; // ---&gt; zhangsan    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    mounted(){        // 在文件中直接可以通过this.$store.state.xxx来访问仓库中的状态        console.log(this.$store.state.name)    }}&lt;/script&gt;</code></pre><ul><li><p>官网建议我们在使用this.$store.state访问仓库的时候最好使用计算属性</p><pre><code>export default {  computed: {      getName(){          return this.$store.state.name      }  },  mounted(){      this.getName()  }    }</code></pre></li><li><p>是不是每次都写this.$store.state.name让你感到厌烦，你实在不想写这个东西怎么办?   </p></li></ul><pre><code>&lt;script&gt;import { mapState } from 'vuex'; // 从vuex中导入mapStateexport default {    mounted() {        console.log(this.name);    },    computed: {        ...mapState(['name'], {aliasAge: 'age'}), // 经过解构后，自动就添加到了计算属性中，此时就可以直接像访问计算属性一样访问它,通过aliasAge还可以取别名    },}&lt;/script&gt;</code></pre><h4 id="了解修饰器：getter的作用"><a href="#了解修饰器：getter的作用" class="headerlink" title="了解修饰器：getter的作用"></a>了解修饰器：getter的作用</h4><blockquote><p>有个需求是这样的，假设你项目有5个页面，其中2个页面使用name，另外3个页面需要在name前面加上hello,怎么操作？</p></blockquote><ul><li>针对那3个页面去修改并在name前加上hello吗？，这样会造成代码冗余，很不好；</li><li>假如下次产品经理让你把 “hello” 改成 “fuck” 的时候，你又得把三个页面都改一遍，想死的心都有啦  </li></ul><blockquote><p>正对这种问题我们有没有解决方案呢？答案是有的，我们可以直接在store中对name进行一些操作或者加工，从源头解决问题！那么具体应该怎么写呢？getters就用上啦  </p></blockquote><pre><code>import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({    state: {        name: 'zhangsan',        age: 20,        friends: [            {name:'wanger', age:18},            {name:'lisi', age:36},            {name:'mazi', age:46}        ]    },    // 在store对象中增加getters属性    getters: {        getMessage(state) { // 获取修饰后的name，第一个参数state为必要参数，必须写在形参上            return `hello${state.name}`;        }    },});export default store;</code></pre><p>在组件中使用：</p><pre><code>export default {    mounted() {        // 注意不是$store.state了，而是$store.getters        console.log(this.$store.state.name);        console.log(this.$store.getters.getMessage);    }}</code></pre><p>和mapState一样，是不是每次都通过this.$store.state.xxx一样麻烦，这个时候我们同样可以使用</p><pre><code>&lt;script&gt;import {mapState, mapGetters} from 'vuex'export default {    mounted(){        console.log(this.name)        console.log(this.getAge)    },    computed: {        ...mapState(['name']),        ...mapGetters(['getAge'])        ...mapGetters({aliasName: 'getPersionAge'})    }}&lt;/script&gt;</code></pre><h4 id="了解如何修改值：Mutation"><a href="#了解如何修改值：Mutation" class="headerlink" title="了解如何修改值：Mutation"></a>了解如何修改值：Mutation</h4><p>🤗 OK！首先恭喜你看到了这里，至此，我们已经成功访问到了store里面的值，接下来我来介绍一下怎么修改state里面的值。</p><p>说到修改值，有的同学就会想到这样写：</p><pre><code>// 错误示范this.$store.state.XXX = XXX;  </code></pre><p>🤪 首先，这里我先明确的说明：这是错误的写法！这是错误的写法！这是错误的写法！</p><p>为什么上面是错误的写法？因为这个store仓库比较奇怪，你可以随便拿，但是你不能随便改，我举个例子：</p><p>🤔 假如你打开微信朋友圈，看到你的好友发了动态，但是动态里有个错别字，你要怎么办呢？你可以帮他改掉吗？当然不可以！我们只能通知他本人去修改，因为是别人的朋友圈，你是无权操作的，只有他自己才能操作，同理，在vuex中，我们不能直接修改仓库里的值，必须用vuex自带的方法去修改，这个时候，Mutation闪亮登场了！</p><p>😬 把问题解释清楚之后，我们准备完成一个效果：我们先输出state中的number的默认值0，然后我们在vue组件里通过提交Mutations改变number的默认值0，改成我们想修改的值，然后再输出出来，这样就可以简单练习怎么使用Mutations了。不说废话，上代码。<br><strong>修改store/index.js</strong></p><pre><code>import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({    state: {        name: '张三',        number: 0,    },    mutations: { // 增加nutations属性        setNumber(state) {  // 增加一个mutations的方法，方法的作用是让num从0变成5，state是必须默认参数            state.number = 5;        }    },});export default store;</code></pre><p><strong>修改App.vue</strong>  </p><pre><code>&lt;script&gt;export default {    mounted() {        console.log(`旧值：${this.$store.state.number}`);        this.$store.commit('setNumber');        console.log(`新值：${this.$store.state.number}`);    },}&lt;/script&gt;</code></pre><p><strong>运行项目，查看控制台：</strong><br><img src="/2022/01/21/vue/vuex/vuex-qian-xi/2.jpg" alt=""><br>🤡 以上是简单实现mutations的方法，是没有传参的，如果我们想传不固定的参数怎么办？接下来教你解决<br><strong>修改store/index.js</strong>  </p><pre><code>import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store({    state: {        name: '张三',        number: 0,    },    mutations: {        setNumber(state) {            state.number = 5;        },        setNumberIsWhat(state, number) { // 增加一个带参数的mutations方法            state.number = number;        },    },});export default store;</code></pre><p><strong>修改App.vue</strong>  </p><pre><code>&lt;script&gt;export default {    mounted() {        console.log(`旧值：${this.$store.state.number}`);        this.$store.commit('setNumberIsWhat', 666);        console.log(`新值：${this.$store.state.number}`);    },}&lt;/script&gt;</code></pre><p><strong>运行项目，查看控制台：</strong><br><img src="/2022/01/21/vue/vuex/vuex-qian-xi/1.jpg" alt=""><br>没有问题！</p><p>注意：上面的这种传参的方式虽然可以达到目的，但是并不推荐，官方建议传递一个对象进去，这样看起来更美观，对象的名字你可以随意命名，但我们一般命名为payload，代码如下：</p><p><strong>修改store/index.js</strong></p><pre><code>mutations: {    setNumber(state) {        state.number = 5;    },    setNumberIsWhat(state, payload) { // 增加一个带参数的mutations方法，并且官方建议payload为一个对象        state.number = payload.number;    },},</code></pre><p><strong>修改App.vue</strong></p><pre><code>&lt;script&gt;export default {    mounted() {        console.log(`旧值：${this.$store.state.number}`);        this.$store.commit('setNumberIsWhat', { number: 666 });  // 调用的时候也需要传递一个对象        console.log(`新值：${this.$store.state.number}`);    },}&lt;/script&gt;</code></pre><p>此时可以得到和之前一样的效果，并且代码更加美观！<br>😱 这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！（别急，后面会讲到异步）</p><p>😱 这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！（别急，后面会讲到异步）</p><p>😱 这里说一条重要原则：Mutations里面的函数必须是同步操作，不能包含异步操作！（别急，后面会讲到异步）</p><p>好的，记住这个重要原则，我们再说一个小技巧：</p><p>🤖 官方建议：就像最开始的mapState和mapGetters一样，我们在组件中可以使用mapMutations以代替this.$store.commit(‘XXX’)，是不是很方便呢？</p><pre><code>&lt;script&gt;import { mapMutations } from 'vuex';export default {    mounted() {        this.setNumberIsWhat({ number: 999 });    },    methods: {   // 注意，mapMutations是解构到methods里面的，而不是计算属性了        ...mapMutations(['setNumberIsWhat']),    },}&lt;/script&gt;</code></pre><p>此时可以得到和之前一样的效果，并且代码又美观了一点！</p><p>当然你也可以给它叫别名，取外号，就像这样：</p><pre><code>methods:{    ...mapMutations({ setNumberIsAlias: 'setNumberIsWhat' }),   // 赋别名的话，这里接收对象，而不是数组}</code></pre><p>🤔 OK，关于Mutation的介绍大致就是这样，另外你也掌握了在定义mutations方法的时候有无参数应该怎么写；并且听取了官方建议，使用mapMutations解构到你的组件内部的methods里，这样你就可以很简单的使用mutations方法啦！</p><p>🤪 上面提到，Mutations只能进行同步操作，所以，我们马上开始下一节，看看使用Actions进行异步操作的时候应该注意什么！</p><h4 id="了解异步操作：Actions"><a href="#了解异步操作：Actions" class="headerlink" title="了解异步操作：Actions"></a>了解异步操作：Actions</h4><p>😆 OK！本节我们来学习使用Actions，Actions存在的意义是假设你在修改state的时候有异步操作，vuex作者不希望你将异步操作放在Mutations中，所以就给你设置了一个区域，让你放异步操作，这就是Actions</p><p>😛 我们直接上一个代码</p><p><strong>修改store/index.js</strong>  </p><pre><code>const store = new Vuex.Store({    state: {        name: '张三',        number: 0,    },    mutations: {        setNumberIsWhat(state, payload) {            state.number = payload.number;        },    },    actions: {   // 增加actions属性        setNum(content) {  // 增加setNum方法，默认第一个参数是content，其值是复制的一份store            return new Promise(resolve =&gt; {  // 我们模拟一个异步操作，1秒后修改number为888                setTimeout(() =&gt; {                    content.commit('setNumberIsWhat', { number: 888 });                    resolve();                }, 1000);            });        }    }});</code></pre><p><strong>修改App.vue</strong>  </p><pre><code>async mounted() {    console.log(`旧值：${this.$store.state.number}`);    await this.$store.dispatch('setNum');    console.log(`新值：${this.$store.state.number}`);},</code></pre><p><strong>运行项目，查看控制台：</strong><br><img src="/2022/01/21/vue/vuex/vuex-qian-xi/3.jpg" alt=""><br>🤓 看了例子，是不是明白了，action就是去提交mutation的，什么异步操作都在action中消化了，最后再去提交mutation的。</p><p>😼 当然，你可以模仿mutation进行传参，就像下面这样：</p><p><strong>修改store/index.js</strong></p><pre><code>actions: {    setNum(content, payload) {   // 增加payload参数        return new Promise(resolve =&gt; {            setTimeout(() =&gt; {                content.commit('setNumberIsWhat', { number: payload.number });                resolve();            }, 1000);        });    },}</code></pre><p><strong>修改App.vue</strong></p><pre><code>async mounted() {    console.log(`旧值：${this.$store.state.number}`);    await this.$store.dispatch('setNum', { number: 611 });    console.log(`新值：${this.$store.state.number}`);},</code></pre><p><strong>运行项目，查看控制台</strong><br><img src="/2022/01/21/vue/vuex/vuex-qian-xi/4.jpg" alt=""><br>没有任何问题！</p><p>🤖 官方建议1：你如果不想一直使用this.$store.dispatch(‘XXX’)这样的写法调用action，你可以采用mapActions的方式，把相关的actions解构到methods中，用this直接调用：</p><pre><code>&lt;script&gt;import { mapActions } from 'vuex';export default {    methods: {        ...mapActions(['setNum']),   // 就像这样，解构到methods中    },    async mounted() {        await this.setNum({ number: 123 });  // 直接这样调用即可    },}&lt;/script&gt;</code></pre><p>当然，你也可以取别名，取外号，就像下面这样：</p><pre><code>...mapActions({ setNumAlias: 'setNum' }),   // 赋别名的话，这里接收对象，而不是数组  </code></pre><p>🤖 官方建议2：在store/index.js中的actions里面，方法的形参可以直接将commit解构出来，这样可以方便后续操作：  </p><pre><code>actions: {    setNum({ commit }) {   // 直接将content结构掉，解构出commit，下面就可以直接调用了        return new Promise(resolve =&gt; {            setTimeout(() =&gt; {                commit('XXXX');  // 直接调用                resolve();            }, 1000);        });    },},</code></pre><p>🤠 OK，看到这里，你应该明白action在vuex的位置了吧，什么时候该用action，什么时候不用它，你肯定有了自己的判断，最主要的判断条件就是我要做的操作是不是异步，这也是action存在的本质。当然，你不要将action和mutation混为一谈，action其实就是mutation的上一级，在action这里处理完异步的一些操作后，后面的修改state就交给mutation去做了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>🤗 好！大致对vuex的讲解就到这里了，看到这里你肯定对vuex不陌生了，你会安装它，配置它，读取state的值，甚至修饰读(Getter)，然后你会修改里面的值了(Mutation)，假如你有异步操作并且需要修改state，那你就要使用Action，这样，你就可以在你的项目中用起来vuex啦！加油吧！🤔</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-数据通信使用记录</title>
      <link href="/2022/01/19/vue/shu-ju-tong-xin/shi-yong-ji-lu/"/>
      <url>/2022/01/19/vue/shu-ju-tong-xin/shi-yong-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="数据通信的使用"><a href="#数据通信的使用" class="headerlink" title="数据通信的使用"></a>数据通信的使用</h2><h3 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h3><blockquote><p>EventBus 又称为事件总线。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的Vuex作为状态管理中心，将通知的概念上升到共享状态层次。   </p></blockquote><h3 id="使用event-bus注意事项"><a href="#使用event-bus注意事项" class="headerlink" title="使用event-bus注意事项"></a>使用event-bus注意事项</h3><p>1、前面提到过，如果使用不善，EventBus会是一种灾难，大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus事件监听。<br>2、等子组件$on去注册事件后就执行了父组件$emit 所以接收不到信息，配合嵌套组件的生命周期<br>3、当点击销毁子组件的时候 子组件还能接收到数据吗？对应的回调函数还能在执行吗？ 答案是 会，事件订阅功能是$eventBus对象完成的，与组件无关，当你点击销毁后 再点击创建又会多了一个订阅事件，依次类推每次点击新建后都会多一个订阅事件<br>4、 在子组件销毁后进行取消订阅事件</p><pre><code>destroyed () {    // 取消对bus事件的监听    this.$bus.$off('bus')}</code></pre><h3 id="全局使用方法"><a href="#全局使用方法" class="headerlink" title="全局使用方法"></a>全局使用方法</h3><p>1、定义一个eventBus  </p><pre><code>import Bus from 'vue';export default {    install(Vue){        Vue.prototype.Bus = new Bus()    }}</code></pre><p>2、在main.js中引入eventBus  </p><pre><code>import vueBus from '@/utils/vueBus.js'Vue.use(vueBus)  </code></pre><p>3、新建一个路由组件同时在建2个组件  </p><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;Component-A&gt;&lt;/Component-A&gt;        &lt;Component-B&gt;&lt;/Component-B&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Component-A from './components/Component-A';import Component-B from './components/Component-B';export default {    name:'vueBus',    data(){        return {        }    }}&lt;/script&gt;</code></pre><p>4、Component-A组件发送事件  </p><pre class="line-numbers language-line-numbers language-json"><code class="language-line-numbers language-json"><template>    <div class="g1-component_warp">        <a-button @click="sendData">发送数据</a-button>    </div></template><script>    export default {        methods:{            sendData(){                this.Bus.$emit('aa', '组件1发送的数据')            }        }    }</script><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、Component-B组件接收事件  </p><pre class="line-numbers language-line-numbers language-json"><code class="language-line-numbers language-json"><template>    <div class="g1-component_warp">        <div>组件2监听组件1 emit的数据: <font color="red">{{msg}}</font></div>    </div></template><script>    export default {        data(){            return {                msg: ''            }        },        mounted(){            this.Bus.$on('aa', arg=> this.msg = arg)        }    }</script><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-mixins记录</title>
      <link href="/2022/01/18/vue/vue-mixins/vue-mixins-hun-ru-de-shi-yong-ji-lu/"/>
      <url>/2022/01/18/vue/vue-mixins/vue-mixins-hun-ru-de-shi-yong-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-mixins记录"><a href="#vue-mixins记录" class="headerlink" title="vue-mixins记录"></a>vue-mixins记录</h1><blockquote><p>mixins（混入）就是定义了一部分公共的方法、计算属性或者钩子函数等 vue 组件中的可复用功能，然后混合进各个组件中使用。下面我们具体来看看怎么使用。</p></blockquote><p>1、在项目中定义mixins</p><pre><code>const TestMixins = {    data() {        return {            msg1: '我是 mixins 中的字符串 msg1',            msg2: '我是 mixins 中的字符串 msg2'        }    },    created() {        console.log('我是 mixins 中的钩子函数 created')        this.hello()        this.say()        this.pay()    },    methods: {        hello() {            console.log('我是 mixins 中的函数 hello')        },        say() {            console.log('我是 mixins 中的函数 say')        }    }}</code></pre><p>2、在使用的组件中导入:</p><pre><code>import TestMixins from '@/mixins/TestMixins'；export default {    mixins: [TestMixins],    data() {        return {            msg1: '我是组件中的字符串 msg1',            sex: '我是组件中的字符串 sex'        }    },    created() {        console.log('我是组件中的钩子函数 created')        this.hello()        this.say()        this.pay()    },    methods: {        hello() {            console.log('我是组件中的函数 hello')        },        pay() {            console.log('我是组件中的函数 pay')        }    }}</code></pre><ul><li>总结 <ul><li>混入对象的钩子将在组件自身钩子之前调用。</li><li>值为对象的选项，例如 data、methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li><li>混入对象中可以使用和调用组件自身变量和函数，且与在组件自身中使用情况一样。</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-mixins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由守卫</title>
      <link href="/2022/01/04/vue/vue-router/vue-lu-you/"/>
      <url>/2022/01/04/vue/vue-router/vue-lu-you/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-router中beforeEach"><a href="#vue-router中beforeEach" class="headerlink" title="vue-router中beforeEach"></a>vue-router中beforeEach</h1><blockquote><p>导航守卫又称路由守卫，实时监控路由跳转时的过程，在路由跳转的各个过程执行相应的操作，类似于生命周期函数，在开发过程中经常被使用，比如用户点击一个页面，如果未登录就调到登录页面，已登录就让用户正常进入。  </p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote><p>全局路由一共分为三类：全局守卫，路由独享的守卫，组件内的守卫。</p></blockquote><h4 id="一、全局守卫"><a href="#一、全局守卫" class="headerlink" title="一、全局守卫"></a>一、全局守卫</h4><ul><li>全局守卫有三种：<ul><li>router.beforeEach（全局前置守卫）</li><li>router.beforeResolve（全局解析守卫）</li><li>router.afterEach（全局后置守卫）</li></ul></li></ul><p>1、 router.beforeEach（全局前置守卫）</p><blockquote><p>以一个简单的例子来解释router.beforeEach假设我们现在做一个这样的需求，用户在未登录的时候进入任意页面，我们就让用户跳转到登录页面，在已登录的时候让用户正常跳转到点击的页面。准备好三个组件：home.vue,login.vue,about.vue  </p></blockquote><pre><code>home.vue的内容：&lt;template&gt;  &lt;div class="hello"&gt;    &lt;button @click="$router.push('/about')"&gt;去关于页面&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: 'home',    data() {      return {}    }  }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;login.vue的内容：&lt;template&gt;    &lt;div&gt;登录页面&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: "about"    }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;about.vue的内容：&lt;template&gt;    &lt;div&gt;关于页面&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: "about"    }&lt;/script&gt;</code></pre><p>2、router配置文件内容：  </p><pre class="line-numbers language-line-numbers language-javascript"><code class="language-line-numbers language-javascript"> import Vue from 'vue' import Router from 'vue-router' import home from '@/components/home' import login from '@/components/login' import about from '@/components/about' Vue.use(Router) const ISLOGIN = true   //登录状态模拟 const router = new Router({   routes: [     {       path: '/',       name: 'home',       component: home,     },     {       path: '/login',       name: 'login',       component: login     },     {       path: '/about',       name: 'about',       component: about     }   ] }) router.beforeEach((to, from, next) => {   //全局全局前置守卫   //to : 将要进入的目标路由对象   //from : 即将离开的目标路由对象   //执行跳转的下一步钩子   console.log(to)   console.log(from)   if(to.name != 'login'){ //如果不是登录页面     if(ISLOGIN)next()   //已登录就执行跳转     else next({name:'login'})   //否则跳转到登录页面   }else{ //如果是登录页面     if(ISLOGIN)next({name:'/'}) //已登录就跳转到首页     else  next()  //否则正常进入登录页面   } }) export default router<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，每次路由跳转，router.beforeEach都会执行，并且接受三个参数</p><ul><li>to记录着将要进入的目标路由对象的信息</li><li>from记录着即将离开的目标路由对象的信息</li><li>next()表示执行下一步</li><li>router.beforeEach就是全局路由跳转时触发执行的函数</li></ul><p>3、router.beforeResolve(全局解析守卫)<br>和全局前置守卫类似，区别是在跳转被确认之前，同时在所有组件内守卫和异步路由组件都被解析之后，解析守卫才调用。</p><p>4、router.afterEach(全局后置钩子)<br>只接受to和from,不会接受 next 函数也不会改变导航本身</p><h3 id="二、路由独享守卫"><a href="#二、路由独享守卫" class="headerlink" title="二、路由独享守卫"></a>二、路由独享守卫</h3><blockquote><p>独享守卫只有一种:beforeEnter。该守卫接收的参数与全局守卫是一样的，但是该守卫只在其他路由跳转至配置有beforeEnter路由表信息时才生效。</p></blockquote><p>router配置文件内容：</p><pre><code>{   path: '/about',   name: 'about',   component: about,   beforeEnter:(to,from,next)=&gt;{      console.log(to);      console.log(from);      next()   }</code></pre><h3 id="三、组件内守卫"><a href="#三、组件内守卫" class="headerlink" title="三、组件内守卫"></a>三、组件内守卫</h3><blockquote><p>组件内守卫一共有三个：<br>    beforeRouteEnter，<br>    beforeRouteUpdate，<br>    beforeRouteLeave<br>三者分别对应：进入该路由时执行，该路由中参数改变时执行，离开该路由时执行。</p></blockquote><pre><code>&lt;template&gt;  &lt;div&gt;关于页面&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: "about",    beforeRouteEnter(to, from, next) {      //进入该路由时执行    },    beforeRouteUpdate(to, from, next) {      //该路由参数更新时执行    },    beforeRouteLeave(to, from, next) {      //离开该路由时执行    }  }&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react生命周期前后对比</title>
      <link href="/2021/07/20/react/sheng-ming-zhou-qi/sheng-ming-zhou-qi/"/>
      <url>/2021/07/20/react/sheng-ming-zhou-qi/sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="React16之前的生命周期"><a href="#React16之前的生命周期" class="headerlink" title="React16之前的生命周期"></a>React16之前的生命周期</h1><ul><li><p>第一阶段，初始化阶段，由ReactDOM.render()触发，初次渲染</p><pre><code>constructor(){} =====&gt; 构造器componentWillMount(){} =======&gt; 组件挂载之前render(){} ======&gt; 挂载结构componentDidMount(){} =======&gt; 组件挂载后，常用钩子，一般用来做一些初始化的事情：开启定时器，发送网络请求，订阅消息</code></pre></li><li><p>更新阶段,this.setSet()或父组件的render触发</p><pre><code>shouldComponentUpdate() { =======&gt; 组件是否被更新  return false;}componentWillUpdate(){} =======&gt; 组件更新前render(){} ======&gt; 挂载结构componentDidUpdate(){} =======&gt; 组件更新后</code></pre></li><li><p>第三阶段，卸载阶段，由ReactDOM.unmountComponentAtNode()触发  </p><pre><code>  componentWillUnmount(){} =======&gt; 组件卸载之前，常用钩子，一般用来做一些收尾事情：关闭定时器，取消订阅消息</code></pre></li></ul><p>综合展示：  </p><pre><code>    1.setState() // 修改数据时触发更新    2.forceUpdate() // 强制更新，不经过shouldComponentUpdate(){}    3.componentWillReceiveProps(){} // 父组件更新引发更新    constructor(){} =====&gt; 构造器    componentWillMount(){} =======&gt; 组件挂载之前    render(){} ======&gt; 挂载结构    componentDidMount(){} =======&gt; 组件挂载后    componentWillUnmount(){} =======&gt; 组件卸载之前    shouldComponentUpdate() { return false } =======&gt; 组件是否被更新    componentWillUpdate(){} =======&gt; 组件更新前    componentDidUpdate(){} =======&gt; 组件更新后</code></pre><h1 id="React16以后的生命周期"><a href="#React16以后的生命周期" class="headerlink" title="React16以后的生命周期"></a>React16以后的生命周期</h1><ul><li>初始化阶段，只执行一次<pre><code>constructor(){} //构造器getDerivedStateFromProps() {}  //从Props获取派生render(){} //挂载结构componentDidMount(){} //组件挂载后</code></pre></li><li>第二阶段：更新阶段，由内部this.setState()或父组件render()触发  <pre><code>getDerivedStateFromProps() {}  =====&gt; 从Props获取派生shouldComponentUpdate() { return false } =======&gt; 组件是否被更新render(){} ======&gt; 挂载结构getSnapshotBeforeUpdate(prevProps, prevState) {} ======&gt; // 获取快照更新前componentDidUpdate(){} =======&gt; 组件更新后</code></pre></li><li>第三阶段：卸载阶段，由ReactDOM.unmountComponentAtNode()触发</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bat添加软件右键打开项目</title>
      <link href="/2021/06/23/soft/bat/bat-tian-jia-ruan-jian-you-jian-da-kai-xiang-mu/"/>
      <url>/2021/06/23/soft/bat/bat-tian-jia-ruan-jian-you-jian-da-kai-xiang-mu/</url>
      
        <content type="html"><![CDATA[<p>@echo Off<br>:START<br>CLS<br>echo <em>=========================================================================</em><br>echo *                        注意: 该bat文件必须和HBuilderX.exe在同级目录  *<br>echo *                            [A]添加右键菜单                              *<br>echo *                            [D]删除右键菜单                              *<br>echo *                            [Q]退出                                      *<br>echo *                                                                         *<br>echo <em>=========================================================================</em><br>Set /P Choice=　　　　　　　请选择要进行的操作 (A/D/Q) ，然后按回车：<br>If /I “%Choice%”==”A” Goto :ADD<br>If /I “%Choice%”==”D” Goto :DEL<br>If /I “%Choice%”==”Q” Exit</p><p>START</p><p>:ADD<br>CLS<br>set str=%cd%<br>echo Windows Registry Editor Version 5.00&gt; tmp.reg<br>echo [HKEY_CLASSES_ROOT*\shell]&gt;&gt; tmp.reg<br>echo [HKEY_CLASSES_ROOT*\shell\HBuilderX]&gt;&gt; tmp.reg<br>echo @=”用Sublime Text打开”&gt;&gt; tmp.reg<br>echo “Icon”=”"%str:=\%\HBuilderX.exe",0”&gt;&gt; tmp.reg<br>echo [HKEY_CLASSES_ROOT*\shell\HBuilderX\Command]&gt;&gt; tmp.reg<br>echo @=”"%str:=\%\HBuilderX.exe" "%%1^"“&gt;&gt; tmp.reg </p><p>echo [HKEY_CLASSES_ROOT\Directory\shell\sublime]&gt;&gt; tmp.reg<br>echo @=”添加到Sublime Text工程项目”&gt;&gt; tmp.reg<br>echo “Icon”=”"%str:=\%\HBuilderX.exe",0”&gt;&gt; tmp.reg<br>echo [HKEY_CLASSES_ROOT\Directory\shell\sublime\Command]&gt;&gt; tmp.reg<br>echo @=”"%str:=\%\HBuilderX.exe" "%%1^"“&gt;&gt; tmp.reg </p><p>echo [HKEY_CLASSES_ROOT\Directory\Background\shell\sublime]&gt;&gt; tmp.reg<br>echo @=”添加到Sublime Text工程项目”&gt;&gt; tmp.reg<br>echo “Icon”=”"%str:=\%\HBuilderX.exe",0”&gt;&gt; tmp.reg<br>echo [HKEY_CLASSES_ROOT\Directory\Background\shell\sublime\Command]&gt;&gt; tmp.reg<br>echo @=”"%str:=\%\HBuilderX.exe" "%%V^"“&gt;&gt; tmp.reg<br>echo <em>=========================================================================</em><br>echo *                                                                         *<br>echo *   正在将生成的注册信息写入注册表，请点击“是”键钮！                      *<br>echo *                                                                         *<br>echo <em>=========================================================================</em><br>tmp.reg<br>del tmp.reg<br>GOTO :START</p><p>:DEL<br>echo Windows Registry Editor Version 5.00&gt; tmp.reg<br>echo [-HKEY_CLASSES_ROOT*\shell\HBuilderX]&gt;&gt; tmp.reg<br>echo [-HKEY_CLASSES_ROOT\Directory\shell\HBuilderX]&gt;&gt; tmp.reg<br>echo [-HKEY_CLASSES_ROOT\Directory\Background\shell\HBuilderX]&gt;&gt; tmp.reg<br>tmp.reg<br>del tmp.reg<br>GOTO :START</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>url-loader+html-loader处理图片不能正常打开</title>
      <link href="/2021/06/06/webpack/chang-jian-wen-ti/url-loader-html-loader-chu-li-tu-pian-bu-neng-zheng-chang-da-kai/"/>
      <url>/2021/06/06/webpack/chang-jian-wen-ti/url-loader-html-loader-chu-li-tu-pian-bu-neng-zheng-chang-da-kai/</url>
      
        <content type="html"><![CDATA[<h3 id="url-loader-html-loader处理图片不能正常打开"><a href="#url-loader-html-loader处理图片不能正常打开" class="headerlink" title="url-loader+html-loader处理图片不能正常打开"></a>url-loader+html-loader处理图片不能正常打开</h3><p>在配置url-loader和html-loader的时候都需要配置esModule: false闭url-loader的es6模块化，使用commonjs解析  </p><p><img src="/2021/06/06/webpack/chang-jian-wen-ti/url-loader-html-loader-chu-li-tu-pian-bu-neng-zheng-chang-da-kai/1.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题锦集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack5+webpack-dev-server兼容</title>
      <link href="/2021/06/06/webpack/chang-jian-wen-ti/webpack5-webpack-dev-server-jian-rong/"/>
      <url>/2021/06/06/webpack/chang-jian-wen-ti/webpack5-webpack-dev-server-jian-rong/</url>
      
        <content type="html"><![CDATA[<h3 id="安装webpack-dev-server-报错Error-Cannot-find-module-‘webpack-cli-bin-config-yargs’"><a href="#安装webpack-dev-server-报错Error-Cannot-find-module-‘webpack-cli-bin-config-yargs’" class="headerlink" title="安装webpack-dev-server 报错Error:Cannot find module ‘webpack-cli/bin/config-yargs’"></a>安装webpack-dev-server 报错Error:Cannot find module ‘webpack-cli/bin/config-yargs’</h3><p><img src="/2021/06/06/webpack/chang-jian-wen-ti/webpack5-webpack-dev-server-jian-rong/20210519111919882.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题锦集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node项目使用import报错问题</title>
      <link href="/2021/05/06/node/node-shi-yong-import-bao-cuo-wen-ti/"/>
      <url>/2021/05/06/node/node-shi-yong-import-bao-cuo-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="在express框架中运用import-export"><a href="#在express框架中运用import-export" class="headerlink" title="在express框架中运用import export"></a>在express框架中运用import export</h1><blockquote><p>在新搭建的基于node.js的express框架时，不能直接运用import/export，否则会报错如下  </p></blockquote><p><img src="/2021/05/06/node/node-shi-yong-import-bao-cuo-wen-ti/1.png" alt=""><br><img src="/2021/05/06/node/node-shi-yong-import-bao-cuo-wen-ti/2.png" alt=""> </p><p>所以需要在入口文件里面导入babel依赖<br>1* yarn add babel-register babel-preset-env –save-dev<br>2* 在./bin/www文件的第一行添加如下代码  </p><pre><code>require('babel-register')({  presets: ['env']});</code></pre><p>3* npm start启动项目，已可以正常运行了  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ant-design时设置DatePicker日期控件中文显示</title>
      <link href="/2021/04/30/javascript/moment/ant-design-shi-she-zhi-datepicker-ri-qi-kong-jian-zhong-wen-xian-shi/"/>
      <url>/2021/04/30/javascript/moment/ant-design-shi-she-zhi-datepicker-ri-qi-kong-jian-zhong-wen-xian-shi/</url>
      
        <content type="html"><![CDATA[<ul><li><p>方式一：在组件中单独设置  </p><pre><code>  import locale from 'antd/lib/date-picker/locale/zh_CN';   &lt;DatePicker locale={locale} /&gt;;</code></pre></li><li><p>方法二：全局设置  </p><blockquote><p>注意：DatePicker、MonthPicker、RangePicker、WeekPicker 部分 locale 是从 value 中读取，所以请先正确设置 moment 的 locale</p></blockquote><pre><code>  // 默认语言为 en-US，如果你需要设置其他语言，推荐在入口文件全局设置 locale  import moment from 'moment';  import 'moment/locale/zh-cn';  moment.locale('zh-cn');  &lt;DatePicker defaultValue={moment('2015-01-01', 'YYYY-MM-DD')} /&gt;;</code></pre><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>以前使用这种方法没有问题，但是最近这样配置的时候出现月和周不能显示中文<br><img src="/2021/04/30/javascript/moment/ant-design-shi-she-zhi-datepicker-ri-qi-kong-jian-zhong-wen-xian-shi/1.jpg" alt=""></p></li><li><p>现在的方法  </p><ul><li><p>新建一个globals.js文件</p><pre><code>  import moment from 'moment';  import 'moment/locale/zh-cn';    export default {       install(Vue, options) {           Vue.prototype.momentUpdate = function(moment){               moment.locale('zh-cn', {                   months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),                   monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),                   weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),                   weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),                   weekdaysMin: '日_一_二_三_四_五_六'.split('_'),                   longDateFormat: {                       LT: 'Ah点mm分',                       LTS: 'Ah点m分s秒',                       L: 'YYYY-MM-DD',                       LL: 'YYYY年MMMD日',                       LLL: 'YYYY年MMMD日Ah点mm分',                       LLLL: 'YYYY年MMMD日ddddAh点mm分',                       l: 'YYYY-MM-DD',                       ll: 'YYYY年MMMD日',                       lll: 'YYYY年MMMD日Ah点mm分',                       llll: 'YYYY年MMMD日ddddAh点mm分'                   },                   meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,                   meridiemHour: function (h, meridiem) {                       let hour = h;                       if (hour === 12) {                           hour = 0;                       }                       if (meridiem === '凌晨' || meridiem === '早上' ||                           meridiem === '上午') {                           return hour;                       } else if (meridiem === '下午' || meridiem === '晚上') {                           return hour + 12;                       } else {                           // '中午'                           return hour &gt;= 11 ? hour : hour + 12;                       }                   },                   meridiem: function (hour, minute, isLower) {                       const hm = hour * 100 + minute;                       if (hm &lt; 600) {                           return '凌晨';                       } else if (hm &lt; 900) {                           return '早上';                       } else if (hm &lt; 1130) {                           return '上午';                       } else if (hm &lt; 1230) {                           return '中午';                       } else if (hm &lt; 1800) {                           return '下午';                       } else {                           return '晚上';                       }                   },                   calendar: {                       sameDay: function () {                           return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';                       },                       nextDay: function () {                           return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';                       },                       lastDay: function () {                           return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';                       },                       nextWeek: function () {                           let startOfWeek, prefix;                           startOfWeek = moment().startOf('week');                           prefix = this.diff(startOfWeek, 'days') &gt;= 7 ? '[下]' : '[本]';                           return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';                       },                       lastWeek: function () {                           let startOfWeek, prefix;                           startOfWeek = moment().startOf('week');                           prefix = this.unix() &lt; startOfWeek.unix() ? '[上]' : '[本]';                           return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';                       },                       sameElse: 'LL'                   },                   ordinalParse: /\d{1,2}(日|月|周)/,                   ordinal: function (number, period) {                       switch (period) {                           case 'd':                           case 'D':                           case 'DDD':                               return number + '日';                           case 'M':                               return number + '月';                           case 'w':                           case 'W':                               return number + '周';                           default:                               return number;                       }                   },                   relativeTime: {                       future: '%s内',                       past: '%s前',                       s: '几秒',                       m: '1 分钟',                       mm: '%d 分钟',                       h: '1 小时',                       hh: '%d 小时',                       d: '1 天',                       dd: '%d 天',                       M: '1 个月',                       MM: '%d 个月',                       y: '1 年',                       yy: '%d 年'                   },                   week: {                       // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效                       dow: 1, // Monday is the first day of the week.                       doy: 4  // The week that contains Jan 4th is the first week of the year.                   }               });           }(moment);       }  }</code></pre></li><li><p>main.js全局引入</p><pre><code>//main.js中引入import globals from '@/utils/globals'Vue.use(globals);</code></pre></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 个人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> moment js vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
